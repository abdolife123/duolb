---
interface Props {
  // Optional: this component primarily reads from `window.__nearbyState`.
  // Keeping props optional avoids TS errors when used as <SalonMap />.
  salons?: {
    latitude: number;
    longitude: number;
    salon_name: string | null;
    slug: string;
  }[];
  userLocation?: {
    latitude: number;
    longitude: number;
  } | null;
}

const { salons = [], userLocation = null } = (Astro.props || {}) as Props;
---

<style>
  #salon-map {
    width: 100%;
    height: 400px;
    border-radius: 12px;
    margin-bottom: 2rem;
  }

  /* Avoid Leaflet tiles bleeding outside rounded corners */
  #salon-map .leaflet-container {
    border-radius: 12px;
  }
</style>

<!-- Leaflet assets (self-contained component). -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  is:inline
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<div id="salon-map"></div>

<script type="module">
const mapScript = async () => {
  // Load Leaflet from CDN if not already loaded.
  if (!window.L) {
    await import("https://unpkg.com/leaflet@1.9.4/dist/leaflet-src.esm.js");
  }

  const L = window.L;
  if (!L) return;

  const DEFAULT_CENTER = [51.1657, 10.4515];

  const getState = () => window.__nearbyState || { salons: [], userLocation: null };

  const map = L.map("salon-map").setView(DEFAULT_CENTER, 12);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; OpenStreetMap contributors",
  }).addTo(map);

  const markers = L.layerGroup().addTo(map);
  let lastSignature = "";

  const signatureFor = (state) => {
    const loc = state?.userLocation;
    const locSig =
      loc && typeof loc.latitude === "number" && typeof loc.longitude === "number"
        ? `${loc.latitude},${loc.longitude}`
        : "null";
    const salons = Array.isArray(state?.salons) ? state.salons : [];
    const salonSig = salons
      .map((s) => `${s?.slug ?? ""}:${s?.latitude ?? ""},${s?.longitude ?? ""}`)
      .join("|");
    return `${locSig}::${salonSig}`;
  };

  const renderFromState = () => {
    const state = getState();
    const sig = signatureFor(state);
    if (sig === lastSignature) return;
    lastSignature = sig;

    markers.clearLayers();

    const userLocation = state.userLocation;
    const salons = Array.isArray(state.salons) ? state.salons : [];

    if (userLocation && userLocation.latitude && userLocation.longitude) {
      map.setView([userLocation.latitude, userLocation.longitude], 12);
      L.marker([userLocation.latitude, userLocation.longitude])
        .addTo(markers)
        .bindPopup("Du bist hier");
    }

    salons.forEach((salon) => {
      if (salon.latitude && salon.longitude) {
        L.marker([salon.latitude, salon.longitude])
          .addTo(markers)
          .bindPopup(
            `<strong>${salon.salon_name ?? ""}</strong><br>
             <a href="/salon/${salon.slug}">Profil ansehen</a>`
          );
      }
    });
  };

  // Render ASAP and keep in sync with the shared global state.
  renderFromState();
  window.addEventListener("nearbyStateUpdated", renderFromState);
  setInterval(renderFromState, 500);
};

mapScript();
</script>
